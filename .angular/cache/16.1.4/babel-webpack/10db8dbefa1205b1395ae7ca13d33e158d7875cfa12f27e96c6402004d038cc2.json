{"ast":null,"code":"import { catchError, of, tap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class PokemonService {\n  constructor(http) {\n    this.http = http;\n  }\n  // getPokemonList(): Pokemon [] {\n  //   // renvoie model\n  //   return POKEMONS;\n  //   // liste des pokémons, réencapsulée dans un service pour profiter du syst d'injection de dépendance\n  // }\n  getPokemonList() {\n    // réception d'une donnée qui va rriver dans le temps qui contient un tab de pokemon, on ne retourne pas directement les pokémons. On retourne un flux\n    return this.http.get('api/pokemons').pipe(tap(pokemonList => console.table(pokemonList)), catchError(error => {\n      console.log(error);\n      return of([]);\n    }));\n    // httpCLient d'angular par défaut renvoie des flux qui oeuvent être typé, la requête get contient un tab de pokemon et on passe une URL vers une API\n    // opérateur .pipe définir ce que l'on veut faire en plus du tmt de la requête: log resp et erreurs\n    // req http get avec le client http angular et on reçoit un observable, on peut spécifier que la réponse contient une liste de pokémon. En pram de la méthode get URL, une fois qu'on a la réponse, on la log et si erreur log erreur et on retourne un tab vide\n    // opérateur rxjs tap = équivalent console log adapté à un observable, il n'intervient pas sur la requête en elle même mais on va pouvoir venir faire des op à chaque nouvelles rep\n    // catch evite l'app de crasher\n  }\n  // getPokemonById(pokemonId :number): Pokemon | undefined {\n  //   return POKEMONS.find(pokemon => pokemon.id == pokemonId);\n  // }\n  getPokemonById(pokemonId) {\n    return this.http.get(`api/pokemons/${pokemonId}`).pipe(tap(pokemon => console.table(pokemon)), catchError(error => {\n      console.log(error);\n      return of(undefined);\n    }));\n  }\n  getPokemonTypeList() {\n    return ['Plante', 'Feu', 'Eau', 'Insecte', 'Normal', 'Electrik', 'Poison', 'Fée', 'Vol', 'Combat', 'Psy'];\n  }\n}\nPokemonService.ɵfac = function PokemonService_Factory(t) {\n  return new (t || PokemonService)(i0.ɵɵinject(i1.HttpClient));\n};\nPokemonService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: PokemonService,\n  factory: PokemonService.ɵfac\n});","map":{"version":3,"names":["catchError","of","tap","PokemonService","constructor","http","getPokemonList","get","pipe","pokemonList","console","table","error","log","getPokemonById","pokemonId","pokemon","undefined","getPokemonTypeList","i0","ɵɵinject","i1","HttpClient","factory","ɵfac"],"sources":["C:\\Users\\utilisateur\\Desktop\\GIT\\ng-pokemon-app\\src\\app\\pokemon\\pokemon.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Pokemon } from './pokemon';\r\nimport { POKEMONS } from './mock-pokemon-list';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable, catchError, of, tap } from 'rxjs';\r\n\r\n@Injectable(\r\n  // {\r\n  // décorateur permet d'indiquer à Angular que notre service peut lui même avoir d'autres dépendances. Pour brancher ce service avec le mécanisms d'injection de dépendances d'Angular.\r\n  // providedIn: 'root'// retiré pour n'être injecté que dans le module considéré\r\n  // cette ppt indique à Angular que l'on veut utiliser la même instance du service à travers toute l'app. Nous ne créerons jamais d'instance nous même\r\n// }\r\n)\r\nexport class PokemonService {\r\n\r\nconstructor(private http: HttpClient) {\r\n\r\n}\r\n\r\n  // getPokemonList(): Pokemon [] {\r\n  //   // renvoie model\r\n  //   return POKEMONS;\r\n  //   // liste des pokémons, réencapsulée dans un service pour profiter du syst d'injection de dépendance\r\n  // }\r\n  getPokemonList(): Observable<Pokemon []> {\r\n    // réception d'une donnée qui va rriver dans le temps qui contient un tab de pokemon, on ne retourne pas directement les pokémons. On retourne un flux\r\n    return this.http.get<Pokemon[]>('api/pokemons').pipe(\r\n        tap((pokemonList) => console.table(pokemonList)),\r\n        catchError((error) => {\r\n          console.log(error);\r\n          return of([]);\r\n        })\r\n    )\r\n    // httpCLient d'angular par défaut renvoie des flux qui oeuvent être typé, la requête get contient un tab de pokemon et on passe une URL vers une API\r\n    // opérateur .pipe définir ce que l'on veut faire en plus du tmt de la requête: log resp et erreurs\r\n    // req http get avec le client http angular et on reçoit un observable, on peut spécifier que la réponse contient une liste de pokémon. En pram de la méthode get URL, une fois qu'on a la réponse, on la log et si erreur log erreur et on retourne un tab vide\r\n    // opérateur rxjs tap = équivalent console log adapté à un observable, il n'intervient pas sur la requête en elle même mais on va pouvoir venir faire des op à chaque nouvelles rep\r\n    // catch evite l'app de crasher\r\n  }\r\n\r\n  // getPokemonById(pokemonId :number): Pokemon | undefined {\r\n  //   return POKEMONS.find(pokemon => pokemon.id == pokemonId);\r\n  // }\r\n  getPokemonById(pokemonId :number): Observable<Pokemon | undefined> {\r\n    return this.http.get<Pokemon>(`api/pokemons/${pokemonId}`).pipe(\r\n      tap((pokemon) => console.table(pokemon)),\r\n        catchError((error) => {\r\n          console.log(error);\r\n          return of(undefined);\r\n        })\r\n    )\r\n  }\r\n\r\n  getPokemonTypeList(): string[] {\r\n    return [\r\n      'Plante', \r\n      'Feu', \r\n      'Eau', \r\n      'Insecte', \r\n      'Normal', \r\n      'Electrik', \r\n      'Poison', \r\n      'Fée', \r\n      'Vol', \r\n      'Combat', \r\n      'Psy'\r\n    ]; \r\n  }\r\n  \r\n}\r\n"],"mappings":"AAIA,SAAqBA,UAAU,EAAEC,EAAE,EAAEC,GAAG,QAAQ,MAAM;;;AAStD,OAAM,MAAOC,cAAc;EAE3BC,YAAoBC,IAAgB;IAAhB,KAAAA,IAAI,GAAJA,IAAI;EAExB;EAEE;EACA;EACA;EACA;EACA;EACAC,cAAcA,CAAA;IACZ;IACA,OAAO,IAAI,CAACD,IAAI,CAACE,GAAG,CAAY,cAAc,CAAC,CAACC,IAAI,CAChDN,GAAG,CAAEO,WAAW,IAAKC,OAAO,CAACC,KAAK,CAACF,WAAW,CAAC,CAAC,EAChDT,UAAU,CAAEY,KAAK,IAAI;MACnBF,OAAO,CAACG,GAAG,CAACD,KAAK,CAAC;MAClB,OAAOX,EAAE,CAAC,EAAE,CAAC;IACf,CAAC,CAAC,CACL;IACD;IACA;IACA;IACA;IACA;EACF;EAEA;EACA;EACA;EACAa,cAAcA,CAACC,SAAiB;IAC9B,OAAO,IAAI,CAACV,IAAI,CAACE,GAAG,CAAU,gBAAgBQ,SAAS,EAAE,CAAC,CAACP,IAAI,CAC7DN,GAAG,CAAEc,OAAO,IAAKN,OAAO,CAACC,KAAK,CAACK,OAAO,CAAC,CAAC,EACtChB,UAAU,CAAEY,KAAK,IAAI;MACnBF,OAAO,CAACG,GAAG,CAACD,KAAK,CAAC;MAClB,OAAOX,EAAE,CAACgB,SAAS,CAAC;IACtB,CAAC,CAAC,CACL;EACH;EAEAC,kBAAkBA,CAAA;IAChB,OAAO,CACL,QAAQ,EACR,KAAK,EACL,KAAK,EACL,SAAS,EACT,QAAQ,EACR,UAAU,EACV,QAAQ,EACR,KAAK,EACL,KAAK,EACL,QAAQ,EACR,KAAK,CACN;EACH;;AAtDWf,cAAc,C;mBAAdA,cAAc,EAAAgB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;AAAA;AAAdnB,cAAc,C;SAAdA,cAAc;EAAAoB,OAAA,EAAdpB,cAAc,CAAAqB;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}