{"ast":null,"code":"// import interface OnInit\nimport { POKEMONS } from './mock-pokemon-list';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./border-card.directive\";\nfunction AppComponent_div_4_span_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 11);\n  }\n}\nfunction AppComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"div\", 5)(2, \"div\", 6);\n    i0.ɵɵelement(3, \"img\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"div\", 8)(5, \"div\", 9)(6, \"p\");\n    i0.ɵɵtext(7);\n    i0.ɵɵpipe(8, \"uppercase\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(9, AppComponent_div_4_span_9_Template, 1, 0, \"span\", 10);\n    i0.ɵɵelementStart(10, \"p\")(11, \"small\");\n    i0.ɵɵtext(12);\n    i0.ɵɵpipe(13, \"date\");\n    i0.ɵɵelementEnd()()()()()();\n  }\n  if (rf & 2) {\n    const pokemon_r1 = ctx.$implicit;\n    i0.ɵɵadvance(3);\n    i0.ɵɵpropertyInterpolate(\"src\", pokemon_r1.picture, i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(4);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(8, 4, pokemon_r1.name));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", pokemon_r1.types);\n    i0.ɵɵadvance(3);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(13, 6, pokemon_r1.created, \"dd/MM/yyyy\"));\n  }\n}\n// la vue est définie dans le template du composant, la logique de la vue sera pilotée par la classe du composant qui est défini plus bas. Si maj dans la ppt, le template se met à jour.\nexport class AppComponent {\n  constructor() {\n    // implements interface OnInit\n    // title = 'Application de pokémons';\n    // décla ppt title. Va venir remplacer la valeur dans le template: `<h1>Welcome to {{title}}!</h1>` \n    // pokemonList = ['Bulbizarre', 'Salamèche', 'Carapuce'];\n    // propriété pokemons qui contient un tab de pokemons => envoie erreur car template lié à la ppt title ne peut pas fonctionner. Il faut pousser la ppt pokemons dans le template\n    this.pokemonList = POKEMONS;\n  }\n  // prop de type Pokemon, choisie par user\n  ngOnInit() {\n    // console.table(pokemonList);\n    // erreur car la pokemonList n'existe pas = scope, la var est définie au dessus, il faut utiliser le this.\n    console.table(this.pokemonList);\n    // afficher un tableau\n    // this.selectPokemon(this.pokemonList[0]);\n    // appel de la méthode.\n  }\n  // définition de la méthode associée à l'interface OnInit. Typage TS: la méthode ne renvoie rien = void\n  // selectPokemon(pokemonName: string) {\n  //   console.log(`Vous avez cliqué sur le pokémon ${pokemonName}`);\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\n  // }\n  // selectPokemon(pokemon: Pokemon) {\n  //   console.log(`Vous avez cliqué sur le pokémon ${pokemon.name}`);\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\n  // }\n  // selectPokemon(event: MouseEvent) {\n  //   // const index: number = (event.target as HTMLInputElement).value; renvoie un string avec value sauf que type number\n  //   // côté template event à un type eventTarget mais que je dois le caster côté class du composant en un autre objet\n  //   // const index: number = Number()(event.target as HTMLInputElement).value; conversion en nbr\n  //   const index: number = +(event.target as HTMLInputElement).value;\n  //   // +conversion en nbr du code à droite de l'opérateur\n  //   // si rien de saisi, en js valeur null comme on caste on transforme null en 0\n  //   console.log(`Vous avez cliqué sur le pokémon ${this.pokemonList[index].name}`);\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\n  // }\n  selectPokemon(pokemonId) {\n    // const id = +pokemonId;\n    // const index =id +1;\n    // réup l'identifiant et pas index\n    const pokemon = this.pokemonList.find(pokemon => pokemon.id == +pokemonId);\n    // pokemon.id nombre et pokemonId string. Possède deux types car find() peu renvoyer deux types \n    if (pokemon) {\n      console.log(`Vous avez demandé le pokémon ${pokemon.name}`);\n      this.pokemonSelected = pokemon;\n    } else {\n      console.log(`Vous avez demandé un pokémon inexistant`);\n      this.pokemonSelected = pokemon;\n      // voir ppt pokemonSelected et double typage\n    }\n  }\n}\n\nAppComponent.ɵfac = function AppComponent_Factory(t) {\n  return new (t || AppComponent)();\n};\nAppComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: AppComponent,\n  selectors: [[\"app-root\"]],\n  decls: 5,\n  vars: 1,\n  consts: [[1, \"center\"], [1, \"container\"], [1, \"row\"], [\"class\", \"col m4 s6\", 4, \"ngFor\", \"ngForOf\"], [1, \"col\", \"m4\", \"s6\"], [\"appBorderCard\", \"\", 1, \"card\", \"horizontal\", \"pink\", \"lighten-4\", \"z-depth-3\"], [1, \"card-image\"], [\"alt\", \"Pokemon image\", 3, \"src\"], [1, \"card-stacked\"], [1, \"card-content\"], [\"class\", \"\", \"{{\", \"\", \"type\", \"\", \"|\", \"\", \"pokemonTypeColor\", \"\", \"}}\", \"\", 4, \"ngFor\", \"ngForOf\"], [\"{{\", \"\", \"type\", \"\", \"|\", \"\", \"pokemonTypeColor\", \"\", \"}}\", \"\", 1, \"\"]],\n  template: function AppComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"h1\", 0);\n      i0.ɵɵtext(1, \"Liste de Pok\\u00E9mons\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(2, \"div\", 1)(3, \"div\", 2);\n      i0.ɵɵtemplate(4, AppComponent_div_4_Template, 14, 9, \"div\", 3);\n      i0.ɵɵelementEnd()();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(4);\n      i0.ɵɵproperty(\"ngForOf\", ctx.pokemonList);\n    }\n  },\n  dependencies: [i1.NgForOf, i2.BorderCardDirective, i1.UpperCasePipe, i1.DatePipe],\n  encapsulation: 2\n});","map":{"version":3,"names":["POKEMONS","i0","ɵɵelement","ɵɵelementStart","ɵɵelementEnd","ɵɵtext","ɵɵtemplate","AppComponent_div_4_span_9_Template","ɵɵadvance","ɵɵpropertyInterpolate","pokemon_r1","picture","ɵɵsanitizeUrl","ɵɵtextInterpolate","ɵɵpipeBind1","name","ɵɵproperty","types","ɵɵpipeBind2","created","AppComponent","constructor","pokemonList","ngOnInit","console","table","selectPokemon","pokemonId","pokemon","find","id","log","pokemonSelected","selectors","decls","vars","consts","template","AppComponent_Template","rf","ctx","AppComponent_div_4_Template"],"sources":["C:\\Users\\utilisateur\\Desktop\\GIT\\ng-pokemon-app\\src\\app\\app.component.ts","C:\\Users\\utilisateur\\Desktop\\GIT\\ng-pokemon-app\\src\\app\\app.component.html"],"sourcesContent":["import { Component, OnInit } from '@angular/core';\r\n// import interface OnInit\r\nimport { POKEMONS } from './mock-pokemon-list'\r\nimport { Pokemon } from './pokemon';\r\n\r\n@Component({\r\n  // décorateur\r\n  selector: 'app-root',\r\n  // template: `<h1>Bienvenue sur {{title}}!</h1>`\r\n  // template: `<h1>Bienvenue sur {{ pokemonList[1] }}!</h1>`\r\n  // template: `<h1>Liste de Pokémons</h1>\r\n  // <p>Ceci est un paragraphe</p>\r\n  // <p>Ceci est un paragraphe</p>\r\n  // <p>Ceci est un paragraphe</p>\r\n  // `\r\n  templateUrl: 'app.component.html'\r\n  // pour écrire le template dans un fichier à part. html et ts dans même fichier pas besoin de chemin relatif\r\n})\r\n// la vue est définie dans le template du composant, la logique de la vue sera pilotée par la classe du composant qui est défini plus bas. Si maj dans la ppt, le template se met à jour.\r\nexport class AppComponent implements OnInit {\r\n  // implements interface OnInit\r\n  // title = 'Application de pokémons';\r\n  // décla ppt title. Va venir remplacer la valeur dans le template: `<h1>Welcome to {{title}}!</h1>` \r\n  // pokemonList = ['Bulbizarre', 'Salamèche', 'Carapuce'];\r\n  // propriété pokemons qui contient un tab de pokemons => envoie erreur car template lié à la ppt title ne peut pas fonctionner. Il faut pousser la ppt pokemons dans le template\r\n  pokemonList: Pokemon[] = POKEMONS; \r\n  //  Ajout d'un type pour éviter de modifier la prop. Indique c'est un tab de pokemon\r\n  pokemonSelected: Pokemon | undefined;\r\n  // prop de type Pokemon, choisie par user\r\n  \r\n  ngOnInit(): void {\r\n    // console.table(pokemonList);\r\n    // erreur car la pokemonList n'existe pas = scope, la var est définie au dessus, il faut utiliser le this.\r\n    console.table(this.pokemonList);\r\n    // afficher un tableau\r\n    // this.selectPokemon(this.pokemonList[0]);\r\n    // appel de la méthode.\r\n  }\r\n  // définition de la méthode associée à l'interface OnInit. Typage TS: la méthode ne renvoie rien = void\r\n\r\n  // selectPokemon(pokemonName: string) {\r\n  //   console.log(`Vous avez cliqué sur le pokémon ${pokemonName}`);\r\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\r\n  // }\r\n  // selectPokemon(pokemon: Pokemon) {\r\n  //   console.log(`Vous avez cliqué sur le pokémon ${pokemon.name}`);\r\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\r\n  // }\r\n  // selectPokemon(event: MouseEvent) {\r\n  //   // const index: number = (event.target as HTMLInputElement).value; renvoie un string avec value sauf que type number\r\n  //   // côté template event à un type eventTarget mais que je dois le caster côté class du composant en un autre objet\r\n  //   // const index: number = Number()(event.target as HTMLInputElement).value; conversion en nbr\r\n  //   const index: number = +(event.target as HTMLInputElement).value;\r\n  //   // +conversion en nbr du code à droite de l'opérateur\r\n  //   // si rien de saisi, en js valeur null comme on caste on transforme null en 0\r\n  //   console.log(`Vous avez cliqué sur le pokémon ${this.pokemonList[index].name}`);\r\n  //   // décla méthode si user clique sur tel élément du tempalte on va venir lier cette méthode qui sera exécutée\r\n  // }\r\n  selectPokemon(pokemonId: string) {\r\n    // const id = +pokemonId;\r\n    // const index =id +1;\r\n    // réup l'identifiant et pas index\r\n    const pokemon: Pokemon | undefined = this.pokemonList.find(pokemon => pokemon.id == +pokemonId);\r\n    // pokemon.id nombre et pokemonId string. Possède deux types car find() peu renvoyer deux types \r\n    if(pokemon){\r\n      console.log(`Vous avez demandé le pokémon ${pokemon.name}`);\r\n      this.pokemonSelected = pokemon;\r\n    } else{\r\n      console.log(`Vous avez demandé un pokémon inexistant`);\r\n      this.pokemonSelected = pokemon;\r\n      // voir ppt pokemonSelected et double typage\r\n    }\r\n  }\r\n}\r\n","<!-- <h1>Liste de Pokémons</h1>\r\n<p>Ceci est un paragraphe</p>\r\n<p>Ceci est un paragraphe</p>\r\n<p>Ceci est un paragraphe</p> -->\r\n<!-- template statique, non lié à la logique métier côtée TS -->\r\n\r\n<!-- <h1>Liste de Pokémons</h1>\r\n<p>{{ pokemonList[0]}}</p>\r\n<p>{{ pokemonList[1]}}</p>\r\n<p>{{ pokemonList[2]}}</p>\r\n<p>{{ pokemonList[11]}}</p> -->\r\n<!-- renvoie [object Object] car tout le POKEMONS est passé -->\r\n<!-- <h1 class=\"center\">Liste de Pokémons</h1> -->\r\n<!-- <input \r\n    type=\"number\"\r\n    (click)=\"selectPokemon($event)\" -->\r\n<!-- /> -->\r\n<!-- !$event-- event remonté par le DOM, , erreur car selectPokemon accepte un pokémon => changer contrat -->\r\n<!-- <input \r\n    #input\r\n    (keyup)=\"0\"\r\n    type=\"text\"\r\n/>\r\n#input déclaration de variable référencée dans le template \r\n<p>{{ input.value }}</p>\r\ninterpolation pour afficher directement le contenu tapé par l'user -->\r\n<!-- <input \r\n    #input\r\n    (keyup.enter)=\"selectPokemon(input.value)\"\r\n    type=\"number\"\r\n/>\r\n<--input.value transmet une chaîne de caractère avec l'index saisi par l'user -->\r\n<!-- <p> Vous avez sélectionné le pokémon: {{ pokemonSelected?.name }}</p> -->\r\n<!--à l'init du composant pokemonSelected n'est pas défini donc =undefined, on dmd à accèder à la prop name undefined => erreur => ? si n'est pas déf n'affiche rien\r\n<p *ngIf=\"pokemonSelected\" class=\"pink-text text-accent-2\"> \r\n    Vous avez sélectionné le pokémon: {{ pokemonSelected?.name }}.\r\n</p>\r\n<p *ngIf=\"!pokemonSelected\" class=\"pink-text text-accent-2\"> \r\n    Aucun pokémon n'a été trouvé.\r\n</p> -->\r\n\r\n<!-- <p>{{ pokemonList[0].name }}</p>\r\n<p>{{ pokemonList[1].name }}</p>\r\n<p>{{ pokemonList[2].name }}</p>\r\n<p>{{ pokemonList[3].name }}</p>\r\n<p>{{ pokemonList[4].name }}</p>\r\n<p>{{ pokemonList[5].name }}</p>\r\n<p>{{ pokemonList[6].name }}</p>\r\n<p>{{ pokemonList[7].name }}</p>\r\n<p>{{ pokemonList[8].name }}</p>\r\n<p>{{ pokemonList[9].name }}</p>\r\n<p>{{ pokemonList[10].name }}</p>\r\n<p>{{ pokemonList[11].name }}</p> -->\r\n\r\n<!-- <p *ngFor=\"let pokemon of pokemonList\" class=\"pink-text text-darken-4, container\">\r\n    {{ pokemon.name }}\r\n</p> -->\r\n<!-- directive structurelle *, tableau doit venir de la classe du composant -->\r\n<!-- <div *ngFor=\"let pokemon of pokemonList\" class=\"card-panel pink lighten-4\">\r\n    <p class=\"pink-text text-darken-4, container\">\r\n        {{ pokemon.name }}\r\n    </p>\r\n    <div>\r\n        <img src=\"{{ pokemon.picture }}\" alt=\"Pokemon image\">\r\n    </div>\r\n</div> -->\r\n\r\n<h1 class=\"center\">Liste de Pokémons</h1>\r\n\r\n<div class=\"container\">\r\n    <div class=\"row\">\r\n        <div *ngFor=\"let pokemon of pokemonList\" class=\"col m4 s6\">\r\n            <div class=\"card horizontal pink lighten-4 z-depth-3\" appBorderCard>\r\n                <div class=\"card-image\">\r\n                    <img src=\"{{ pokemon.picture }}\" alt=\"Pokemon image\">\r\n                </div>\r\n                <div class=\"card-stacked\">\r\n                    <div class=\"card-content\">\r\n                        <p>{{ pokemon.name | uppercase}}</p>\r\n                        <span *ngFor=\"let type of pokemon.types\" class=\"\"{{ type | pokemonTypeColor }}>\r\n\r\n                        </span>\r\n                        <p><small>{{ pokemon.created | date:\"dd/MM/yyyy\" }}</small></p>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>"],"mappings":"AACA;AACA,SAASA,QAAQ,QAAQ,qBAAqB;;;;;;IC6EtBC,EAAA,CAAAC,SAAA,eAEO;;;;;IAVvBD,EAAA,CAAAE,cAAA,aAA2D;IAG/CF,EAAA,CAAAC,SAAA,aAAqD;IACzDD,EAAA,CAAAG,YAAA,EAAM;IACNH,EAAA,CAAAE,cAAA,aAA0B;IAEfF,EAAA,CAAAI,MAAA,GAA6B;;IAAAJ,EAAA,CAAAG,YAAA,EAAI;IACpCH,EAAA,CAAAK,UAAA,IAAAC,kCAAA,mBAEO;IACPN,EAAA,CAAAE,cAAA,SAAG;IAAOF,EAAA,CAAAI,MAAA,IAAyC;;IAAAJ,EAAA,CAAAG,YAAA,EAAQ;;;;IAR1DH,EAAA,CAAAO,SAAA,GAA2B;IAA3BP,EAAA,CAAAQ,qBAAA,QAAAC,UAAA,CAAAC,OAAA,EAAAV,EAAA,CAAAW,aAAA,CAA2B;IAIzBX,EAAA,CAAAO,SAAA,GAA6B;IAA7BP,EAAA,CAAAY,iBAAA,CAAAZ,EAAA,CAAAa,WAAA,OAAAJ,UAAA,CAAAK,IAAA,EAA6B;IACTd,EAAA,CAAAO,SAAA,GAAgB;IAAhBP,EAAA,CAAAe,UAAA,YAAAN,UAAA,CAAAO,KAAA,CAAgB;IAG7BhB,EAAA,CAAAO,SAAA,GAAyC;IAAzCP,EAAA,CAAAY,iBAAA,CAAAZ,EAAA,CAAAiB,WAAA,QAAAR,UAAA,CAAAS,OAAA,gBAAyC;;;ADhE3E;AACA,OAAM,MAAOC,YAAY;EAdzBC,YAAA;IAeE;IACA;IACA;IACA;IACA;IACA,KAAAC,WAAW,GAActB,QAAQ;;EAGjC;EAEAuB,QAAQA,CAAA;IACN;IACA;IACAC,OAAO,CAACC,KAAK,CAAC,IAAI,CAACH,WAAW,CAAC;IAC/B;IACA;IACA;EACF;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAI,aAAaA,CAACC,SAAiB;IAC7B;IACA;IACA;IACA,MAAMC,OAAO,GAAwB,IAAI,CAACN,WAAW,CAACO,IAAI,CAACD,OAAO,IAAIA,OAAO,CAACE,EAAE,IAAI,CAACH,SAAS,CAAC;IAC/F;IACA,IAAGC,OAAO,EAAC;MACTJ,OAAO,CAACO,GAAG,CAAC,gCAAgCH,OAAO,CAACb,IAAI,EAAE,CAAC;MAC3D,IAAI,CAACiB,eAAe,GAAGJ,OAAO;KAC/B,MAAK;MACJJ,OAAO,CAACO,GAAG,CAAC,yCAAyC,CAAC;MACtD,IAAI,CAACC,eAAe,GAAGJ,OAAO;MAC9B;;EAEJ;;;AArDWR,YAAY,C;mBAAZA,YAAY;AAAA;AAAZA,YAAY,C;QAAZA,YAAY;EAAAa,SAAA;EAAAC,KAAA;EAAAC,IAAA;EAAAC,MAAA;EAAAC,QAAA,WAAAC,sBAAAC,EAAA,EAAAC,GAAA;IAAA,IAAAD,EAAA;MCgDzBtC,EAAA,CAAAE,cAAA,YAAmB;MAAAF,EAAA,CAAAI,MAAA,6BAAiB;MAAAJ,EAAA,CAAAG,YAAA,EAAK;MAEzCH,EAAA,CAAAE,cAAA,aAAuB;MAEfF,EAAA,CAAAK,UAAA,IAAAmC,2BAAA,kBAeM;MACVxC,EAAA,CAAAG,YAAA,EAAM;;;MAhBuBH,EAAA,CAAAO,SAAA,GAAc;MAAdP,EAAA,CAAAe,UAAA,YAAAwB,GAAA,CAAAlB,WAAA,CAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}